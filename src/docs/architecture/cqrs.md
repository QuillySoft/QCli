# ‚ö° CQRS Implementation in QCLI

This guide explains how QCLI implements Command Query Responsibility Segregation (CQRS) pattern using MediatR, providing clear separation between read and write operations.

## üìã Table of Contents

- [CQRS Overview](#cqrs-overview)
- [Commands](#commands)
- [Queries](#queries)
- [MediatR Integration](#mediatr-integration)
- [Generated Examples](#generated-examples)
- [Performance Considerations](#performance-considerations)
- [Best Practices](#best-practices)
- [Advanced Patterns](#advanced-patterns)

## CQRS Overview

### üéØ What is CQRS?

**Command Query Responsibility Segregation (CQRS)** separates read and write operations into different models:

- **Commands**: Modify application state (Create, Update, Delete)
- **Queries**: Retrieve data without side effects (Get, List, Search)

### üîÑ Benefits of CQRS

1. **Clear Separation**: Read and write models can be optimized independently
2. **Scalability**: Read and write operations can scale differently
3. **Complexity Management**: Complex business logic separated from data retrieval
4. **Performance**: Optimized queries for specific read scenarios
5. **Security**: Different authorization rules for reads vs writes

### üèóÔ∏è QCLI's CQRS Architecture

```
Request ‚Üí Controller ‚Üí Command/Query ‚Üí Handler ‚Üí Domain/Database ‚Üí Response
                           ‚Üì             ‚Üì
                      MediatR      Business Logic
                      Pipeline      Validation
                                   Authorization
```

## Commands

Commands represent **write operations** that change application state.

### üìù Command Structure

```csharp
[Authorize(Permissions = [Permissions.Products.Actions.Create])]
public sealed class CreateProductCommand(ProductForCreateUpdateDto productDto) : IRequest<Guid>
{
    public ProductForCreateUpdateDto ProductDto { get; } = productDto;
    
    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<CreateProductCommand, Guid>
    {
        public async Task<Guid> Handle(
            CreateProductCommand request, 
            CancellationToken cancellationToken)
        {
            // Business logic here
            var product = new Product(Guid.NewGuid(), request.ProductDto.Name);
            dbContext.Products.Add(product);
            await dbContext.SaveChangesAsync(cancellationToken);
            return product.Id;
        }
    }
}
```

### üîß Command Characteristics

- **Imperative**: Commands express intent (CreateProduct, UpdateOrder)
- **State Changing**: Modify application state
- **Return Minimal Data**: Usually return ID or void/Unit
- **Validated**: Include business rule validation
- **Authorized**: Require appropriate permissions
- **Transactional**: Wrapped in database transactions

### üìä Generated Command Types

#### Create Commands
```csharp
// Generated by: qcli add Product --create
[Authorize(Permissions = [Permissions.Products.Actions.Create])]
public sealed class CreateProductCommand(ProductForCreateUpdateDto productDto) : IRequest<Guid>
{
    public ProductForCreateUpdateDto ProductDto { get; } = productDto;

    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<CreateProductCommand, Guid>
    {
        public async Task<Guid> Handle(
            CreateProductCommand request, 
            CancellationToken cancellationToken)
        {
            var product = new Product(Guid.NewGuid(), request.ProductDto.Name);
            dbContext.Products.Add(product);
            await dbContext.SaveChangesAsync(cancellationToken);
            return product.Id;
        }
    }
}
```

#### Update Commands
```csharp
// Generated by: qcli add Product --update
[Authorize(Permissions = [Permissions.Products.Actions.Update])]
public sealed class UpdateProductCommand(Guid productId, ProductForCreateUpdateDto productDto) 
    : IRequest<Unit>
{
    public Guid ProductId { get; } = productId;
    public ProductForCreateUpdateDto ProductDto { get; } = productDto;

    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<UpdateProductCommand, Unit>
    {
        public async Task<Unit> Handle(
            UpdateProductCommand request, 
            CancellationToken cancellationToken)
        {
            var product = await dbContext.Products
                .SingleOrDefaultAsync(x => x.Id == request.ProductId, cancellationToken)
                ?? throw new NotFoundException(nameof(Product), request.ProductId);

            product.Update(request.ProductDto.Name);
            await dbContext.SaveChangesAsync(cancellationToken);
            return Unit.Value;
        }
    }
}
```

#### Delete Commands
```csharp
// Generated by: qcli add Product --delete
[Authorize(Permissions = [Permissions.Products.Actions.Delete])]
public sealed class DeleteProductCommand(Guid productId) : IRequest<Unit>
{
    public Guid ProductId { get; } = productId;

    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<DeleteProductCommand, Unit>
    {
        public async Task<Unit> Handle(
            DeleteProductCommand request, 
            CancellationToken cancellationToken)
        {
            var product = await dbContext.Products
                .SingleOrDefaultAsync(x => x.Id == request.ProductId, cancellationToken)
                ?? throw new NotFoundException(nameof(Product), request.ProductId);

            dbContext.Products.Remove(product);
            await dbContext.SaveChangesAsync(cancellationToken);
            return Unit.Value;
        }
    }
}
```

### ‚úÖ Command Validation

Every command includes a companion validator:

```csharp
public sealed class CreateProductCommandValidator : AbstractValidator<CreateProductCommand>
{
    public CreateProductCommandValidator()
    {
        RuleFor(x => x.ProductDto.Name)
            .NotEmpty()
            .WithMessage("Product name is required")
            .MaximumLength(200)
            .WithMessage("Product name cannot exceed 200 characters");
    }
}
```

## Queries

Queries represent **read operations** that retrieve data without side effects.

### üîç Query Structure

```csharp
[Authorize(Permissions = [Permissions.Products.Actions.View])]
public sealed class GetProductsQuery(PaginatedRequestDto requestDto) 
    : IRequest<PaginatedList<ProductForListDto>>
{
    public PaginatedRequestDto RequestDto { get; } = requestDto;

    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<GetProductsQuery, PaginatedList<ProductForListDto>>
    {
        public async Task<PaginatedList<ProductForListDto>> Handle(
            GetProductsQuery request, 
            CancellationToken cancellationToken)
        {
            var query = dbContext.Products
                .AsNoTracking()  // Read-only optimization
                .AsQueryable();

            // Apply filtering
            if (!string.IsNullOrWhiteSpace(request.RequestDto.Search))
            {
                var search = request.RequestDto.Search.ToLower();
                query = query.Where(x => x.Name.ToLower().Contains(search));
            }

            return await query
                .ProjectToListAsync<ProductForListDto>(
                    request.RequestDto, 
                    cancellationToken);
        }
    }
}
```

### üîß Query Characteristics

- **Descriptive**: Queries describe what data to retrieve
- **Read-Only**: Never modify application state
- **Optimized**: Use projections and AsNoTracking()
- **Paginated**: Support pagination for large datasets
- **Filterable**: Include search and filtering capabilities
- **Cacheable**: Can be cached for performance

### üìä Generated Query Types

#### List Queries (with Pagination)
```csharp
// Generated by: qcli add Product --read
[Authorize(Permissions = [Permissions.Products.Actions.View])]
public sealed class GetProductsQuery(PaginatedRequestDto requestDto) 
    : IRequest<PaginatedList<ProductForListDto>>
{
    public PaginatedRequestDto RequestDto { get; } = requestDto;

    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<GetProductsQuery, PaginatedList<ProductForListDto>>
    {
        public async Task<PaginatedList<ProductForListDto>> Handle(
            GetProductsQuery request, 
            CancellationToken cancellationToken)
        {
            var query = dbContext.Products
                .AsNoTracking()
                .AsQueryable();

            // Search functionality
            if (!string.IsNullOrWhiteSpace(request.RequestDto.Search))
            {
                var search = request.RequestDto.Search.ToLower();
                query = query.Where(x => x.Name.ToLower().Contains(search));
            }

            // Projection to DTO
            return await query
                .ProjectToListAsync<ProductForListDto>(
                    request.RequestDto, 
                    cancellationToken);
        }
    }
}
```

#### Detail Queries (Get by ID)
```csharp
// Generated by: qcli add Product --read
[Authorize(Permissions = [Permissions.Products.Actions.Profile])]
public sealed class GetProductByIdQuery(Guid productId) : IRequest<ProductForReadDto>
{
    public Guid ProductId { get; } = productId;

    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<GetProductByIdQuery, ProductForReadDto>
    {
        public async Task<ProductForReadDto> Handle(
            GetProductByIdQuery request, 
            CancellationToken cancellationToken)
        {
            var product = await dbContext.Products
                .AsNoTracking()
                .Where(x => x.Id == request.ProductId)
                .ProjectTo<ProductForReadDto>()
                .SingleOrDefaultAsync(cancellationToken)
                ?? throw new NotFoundException(nameof(Product), request.ProductId);

            return product;
        }
    }
}
```

## MediatR Integration

QCLI uses **MediatR** to implement the mediator pattern for CQRS.

### üîå MediatR Pipeline

```
Request ‚Üí MediatR ‚Üí [Behaviors] ‚Üí Handler ‚Üí Response
                      ‚Üì
                 - Authorization
                 - Validation  
                 - Logging
                 - Caching
                 - Transactions
```

### üì¶ Key MediatR Interfaces

```csharp
// Commands (modify state)
public interface IRequest<out TResponse> { }
public interface IRequestHandler<in TRequest, TResponse> 
    where TRequest : IRequest<TResponse>
{
    Task<TResponse> Handle(TRequest request, CancellationToken cancellationToken);
}

// Queries (read-only)
public interface IRequest<out TResponse> { }  // Same interface
public interface IRequestHandler<in TRequest, TResponse> 
    where TRequest : IRequest<TResponse>
{
    Task<TResponse> Handle(TRequest request, CancellationToken cancellationToken);
}

// Events (notifications)
public interface INotification { }
public interface INotificationHandler<in TNotification> 
    where TNotification : INotification
{
    Task Handle(TNotification notification, CancellationToken cancellationToken);
}
```

### üéØ Controller Integration

Controllers use MediatR's `ISender` to dispatch commands and queries:

```csharp
[ApiController]
[Route("api/[controller]")]
public sealed class ProductsController(ISender sender) : ControllerBase
{
    // Command: Create Product
    [HttpPost]
    public async Task<ActionResult<Guid>> Post(
        ProductForCreateUpdateDto productDto, 
        CancellationToken cancellationToken)
    {
        var result = await sender.Send(
            new CreateProductCommand(productDto), 
            cancellationToken);
        return Ok(result);
    }

    // Query: Get Products List
    [HttpGet]
    public async Task<ActionResult<PaginatedList<ProductForListDto>>> Get(
        [FromQuery] PaginatedRequestDto requestDto, 
        CancellationToken cancellationToken)
    {
        var result = await sender.Send(
            new GetProductsQuery(requestDto), 
            cancellationToken);
        return Ok(result);
    }

    // Query: Get Product by ID
    [HttpGet("{id:guid}")]
    public async Task<ActionResult<ProductForReadDto>> GetById(
        Guid id, 
        CancellationToken cancellationToken)
    {
        var result = await sender.Send(
            new GetProductByIdQuery(id), 
            cancellationToken);
        return Ok(result);
    }
}
```

## Generated Examples

### üõçÔ∏è E-commerce Example

```bash
# Generate complete e-commerce entities
qcli add Product --all
qcli add Category --all
qcli add Order --all --entity-type FullyAudited
qcli add OrderItem --all
```

#### Product Commands
```csharp
// Create Product Command
var command = new CreateProductCommand(new ProductForCreateUpdateDto
{
    Name = "Laptop",
    CategoryId = categoryId,
    Price = 999.99m
});
var productId = await sender.Send(command);

// Update Product Command
var updateCommand = new UpdateProductCommand(productId, new ProductForCreateUpdateDto
{
    Name = "Gaming Laptop",
    CategoryId = categoryId,
    Price = 1299.99m
});
await sender.Send(updateCommand);
```

#### Product Queries
```csharp
// Get Products with Search and Pagination
var query = new GetProductsQuery(new PaginatedRequestDto
{
    PageNumber = 1,
    PageSize = 10,
    Search = "laptop"
});
var products = await sender.Send(query);

// Get Product Details
var detailQuery = new GetProductByIdQuery(productId);
var product = await sender.Send(detailQuery);
```

### üìä CRM Example

```bash
# Generate CRM entities
qcli add Contact --all --entity-type FullyAudited
qcli add Company --all --entity-type FullyAudited
qcli add Opportunity --all
```

#### Complex Query Example
```csharp
[Authorize(Permissions = [Permissions.Opportunities.Actions.View])]
public sealed class GetOpportunitiesByCompanyQuery(Guid companyId, PaginatedRequestDto requestDto) 
    : IRequest<PaginatedList<OpportunityForListDto>>
{
    public Guid CompanyId { get; } = companyId;
    public PaginatedRequestDto RequestDto { get; } = requestDto;

    public sealed class Handler(IApplicationDbContext dbContext) 
        : IRequestHandler<GetOpportunitiesByCompanyQuery, PaginatedList<OpportunityForListDto>>
    {
        public async Task<PaginatedList<OpportunityForListDto>> Handle(
            GetOpportunitiesByCompanyQuery request, 
            CancellationToken cancellationToken)
        {
            var query = dbContext.Opportunities
                .AsNoTracking()
                .Where(x => x.CompanyId == request.CompanyId)
                .Include(x => x.Contact)
                .AsQueryable();

            // Apply status filter
            if (!string.IsNullOrWhiteSpace(request.RequestDto.Search))
            {
                query = query.Where(x => x.Title.Contains(request.RequestDto.Search) ||
                                       x.Contact.Name.Contains(request.RequestDto.Search));
            }

            return await query
                .ProjectToListAsync<OpportunityForListDto>(
                    request.RequestDto, 
                    cancellationToken);
        }
    }
}
```

## Performance Considerations

### üöÄ Query Optimizations

1. **AsNoTracking()**: Used for all read operations
```csharp
var query = dbContext.Products
    .AsNoTracking()  // Don't track changes
    .AsQueryable();
```

2. **Projection**: Select only needed fields
```csharp
var products = await dbContext.Products
    .AsNoTracking()
    .Select(x => new ProductForListDto
    {
        Id = x.Id,
        Name = x.Name,
        Price = x.Price
    })
    .ToListAsync(cancellationToken);
```

3. **Pagination**: Limit data transfer
```csharp
public async Task<PaginatedList<T>> ProjectToListAsync<T>(
    IQueryable<TSource> query,
    PaginatedRequestDto request, 
    CancellationToken cancellationToken)
{
    var totalCount = await query.CountAsync(cancellationToken);
    
    var items = await query
        .Skip((request.PageNumber - 1) * request.PageSize)
        .Take(request.PageSize)
        .ProjectTo<T>()
        .ToListAsync(cancellationToken);
        
    return new PaginatedList<T>(items, totalCount, request.PageNumber, request.PageSize);
}
```

### üìà Command Optimizations

1. **Minimal Queries**: Load only necessary data
```csharp
// Instead of loading full entity
var product = await dbContext.Products.FindAsync(productId);

// Load only what's needed
var product = await dbContext.Products
    .Where(x => x.Id == productId)
    .Select(x => new { x.Id, x.Name })
    .SingleOrDefaultAsync();
```

2. **Batch Operations**: Use AddRange, UpdateRange
```csharp
// Batch insert
var products = orderItems.Select(x => new Product(x.Id, x.Name));
dbContext.Products.AddRange(products);
await dbContext.SaveChangesAsync();
```

## Best Practices

### üéØ Command Best Practices

1. **Single Responsibility**: One command per business operation
2. **Immutable Commands**: Commands should be read-only after creation
3. **Validation**: Always validate commands before processing
4. **Error Handling**: Use specific exception types
5. **Return Minimal Data**: Commands return IDs or Unit

```csharp
// ‚úÖ Good: Single responsibility
public sealed class CreateProductCommand : IRequest<Guid> { }
public sealed class UpdateProductPriceCommand : IRequest { }

// ‚ùå Bad: Multiple responsibilities  
public sealed class ManageProductCommand : IRequest { }
```

### üéØ Query Best Practices

1. **Read-Only**: Never modify state in queries
2. **Projections**: Use DTOs for data transfer
3. **Filtering**: Support search and filtering
4. **Pagination**: Always paginate large datasets
5. **Caching**: Cache frequently accessed data

```csharp
// ‚úÖ Good: Optimized query
public async Task<PaginatedList<ProductForListDto>> Handle(...)
{
    return await dbContext.Products
        .AsNoTracking()
        .Where(filter)
        .ProjectTo<ProductForListDto>()
        .ToPaginatedListAsync(request);
}

// ‚ùå Bad: Loading full entities
public async Task<List<Product>> Handle(...)
{
    return await dbContext.Products.ToListAsync();
}
```

### üéØ Handler Best Practices

1. **Dependency Injection**: Use constructor injection
2. **Async Operations**: Always use async/await
3. **Cancellation**: Support cancellation tokens
4. **Error Handling**: Use domain exceptions
5. **Transactions**: Leverage EF's unit of work

## Advanced Patterns

### üîÑ Domain Events

When `generateEvents` is enabled, QCLI generates domain events:

```csharp
// Domain Event
public sealed class ProductCreatedEvent(Guid productId) : INotification
{
    public Guid ProductId { get; } = productId;
}

// Event Handler
public sealed class ProductCreatedEventHandler(IEmailService emailService) 
    : INotificationHandler<ProductCreatedEvent>
{
    public async Task Handle(ProductCreatedEvent notification, CancellationToken cancellationToken)
    {
        // Send welcome email, update analytics, etc.
        await emailService.SendProductCreatedNotificationAsync(notification.ProductId);
    }
}

// In Command Handler
public async Task<Guid> Handle(CreateProductCommand request, CancellationToken cancellationToken)
{
    var product = new Product(Guid.NewGuid(), request.ProductDto.Name);
    dbContext.Products.Add(product);
    await dbContext.SaveChangesAsync(cancellationToken);
    
    // Publish domain event
    await publisher.Publish(new ProductCreatedEvent(product.Id), cancellationToken);
    
    return product.Id;
}
```

### üîÑ Pipeline Behaviors

Add cross-cutting concerns using MediatR behaviors:

```csharp
// Validation Behavior
public sealed class ValidationBehavior<TRequest, TResponse>(
    IEnumerable<IValidator<TRequest>> validators) 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    public async Task<TResponse> Handle(
        TRequest request, 
        RequestHandlerDelegate<TResponse> next, 
        CancellationToken cancellationToken)
    {
        if (validators.Any())
        {
            var context = new ValidationContext<TRequest>(request);
            var validationResults = await Task.WhenAll(
                validators.Select(v => v.ValidateAsync(context, cancellationToken)));
                
            var failures = validationResults
                .SelectMany(r => r.Errors)
                .Where(f => f != null)
                .ToList();

            if (failures.Any())
                throw new ValidationException(failures);
        }

        return await next();
    }
}

// Performance Logging Behavior
public sealed class PerformanceBehavior<TRequest, TResponse>(ILogger<TRequest> logger) 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    public async Task<TResponse> Handle(
        TRequest request, 
        RequestHandlerDelegate<TResponse> next, 
        CancellationToken cancellationToken)
    {
        var stopwatch = Stopwatch.StartNew();
        
        var response = await next();
        
        stopwatch.Stop();
        
        if (stopwatch.ElapsedMilliseconds > 500)
        {
            logger.LogWarning("Long Running Request: {Name} ({ElapsedMilliseconds} ms) {@Request}",
                typeof(TRequest).Name, stopwatch.ElapsedMilliseconds, request);
        }
        
        return response;
    }
}
```

### üîÑ Request/Response Pattern

For complex scenarios, use request/response objects:

```csharp
// Complex Query Request
public sealed class GetProductsRequest
{
    public string? Search { get; set; }
    public Guid? CategoryId { get; set; }
    public decimal? MinPrice { get; set; }
    public decimal? MaxPrice { get; set; }
    public ProductStatus? Status { get; set; }
    public PaginatedRequestDto Pagination { get; set; } = new();
}

// Query with Complex Request
public sealed class GetProductsQuery(GetProductsRequest request) 
    : IRequest<PaginatedList<ProductForListDto>>
{
    public GetProductsRequest Request { get; } = request;
}
```

---

**Related Documentation:**
- [Clean Architecture](clean-architecture.md) - Overall architecture patterns
- [Entity Types](entity-types.md) - Understanding entity inheritance
- [Permissions](permissions.md) - Authorization structure
- [Configuration Guide](../configuration/configuration.md) - Project configuration
